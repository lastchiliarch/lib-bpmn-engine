{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"lib-bpmn-engine Motivation A BPMN engine, meant to be embedded in Go applications with minimum hurdles, and a pleasant developer experience using it. This approach can increase transparency of code/implementation for non-developers. This library is meant to be embedded in your application and should not introduce more runtime-dependencies. Hence, there's no database support built nor planned. Also, the engine is not agnostic to any high availability approaches, like multiple instances or similar. See Getting Started There's an experimental online playground https://nitram509.github.io/lib-bpmn-engine-js/ available, which leverages the great power of cross-compiling to WASM. Philosophies around BPMN The BPMN specification in its core is a set of graphical symbols (rectangles, arrows, etc.) and a standard definition about how to read/interpret them. With this foundation, it's an excellent opportunity to enrich transparency or communication or discussions about implementation details. So BPMN has a great potential to support me as a developer to not write documentation into a wiki but rather expose the business process via well known symbols/graphics. There's a conceptual similarity in usage between BPMN and OpenAPI/Swagger. As developers, on the one hand side we often use OpenAPI/Swagger to document our endpoints, HTTP methods, and purpose of the (HTTP) interface, our services offer. Hence, we enable others to use and integrate them. With BPMN on the other hand it can be conceptual similar, when it comes to share internal behaviour of our services. I see even larger similarity, when it comes to the question: How do I maintain the documentation? Again, on the one hand side with OpenAPI/Swagger, we tend to either use reflection and code generators or we follow the API spec first approach. The later one is addressed by this library in the BPMN context: Business Process spec first approach goals and development guidelines (for the engine) The lib-bpmn-engine library follows these architectural goals/guidelines being graceful in reading BPMN files support multiple (named) instances of the engine within the same process support BPMN elements, as guided/requested by the community (means incremental feature development) not being standard compliant (as in tolerating some errors) no linting/validation of BPMN no database support (just (de-)marshalling is planned) no locking/synchronization support (should be implemented by the application itself) no built-in user interface (but export of events, so UI could be use or built) no built-in scheduler/timer (but can be provided) no support for BPMN compensation spec (which I consider bad practice, for the same reason, why roll-back is more complicated than roll-forward-with-fix) Main Features in-memory BPMN engine, to be embedded in other Go applications able to execute BPMN 2.0 xml workflow models no database support by design - there's just marshalling/unmarshalling support planned generic event export interface to make internal processing transparent basic BPMN element supported, see Supported Elements support dynamic decision via expression language support The following experimental features have known limitations, and rather showcase some capabilities. Experimental features might even be removed in the future! EXPERIMENTAL: event exporter for Zeebe Simple Process Monitor","title":"Home"},{"location":"#lib-bpmn-engine","text":"","title":"lib-bpmn-engine"},{"location":"#motivation","text":"A BPMN engine, meant to be embedded in Go applications with minimum hurdles, and a pleasant developer experience using it. This approach can increase transparency of code/implementation for non-developers. This library is meant to be embedded in your application and should not introduce more runtime-dependencies. Hence, there's no database support built nor planned. Also, the engine is not agnostic to any high availability approaches, like multiple instances or similar. See Getting Started There's an experimental online playground https://nitram509.github.io/lib-bpmn-engine-js/ available, which leverages the great power of cross-compiling to WASM.","title":"Motivation"},{"location":"#philosophies-around-bpmn","text":"The BPMN specification in its core is a set of graphical symbols (rectangles, arrows, etc.) and a standard definition about how to read/interpret them. With this foundation, it's an excellent opportunity to enrich transparency or communication or discussions about implementation details. So BPMN has a great potential to support me as a developer to not write documentation into a wiki but rather expose the business process via well known symbols/graphics. There's a conceptual similarity in usage between BPMN and OpenAPI/Swagger. As developers, on the one hand side we often use OpenAPI/Swagger to document our endpoints, HTTP methods, and purpose of the (HTTP) interface, our services offer. Hence, we enable others to use and integrate them. With BPMN on the other hand it can be conceptual similar, when it comes to share internal behaviour of our services. I see even larger similarity, when it comes to the question: How do I maintain the documentation? Again, on the one hand side with OpenAPI/Swagger, we tend to either use reflection and code generators or we follow the API spec first approach. The later one is addressed by this library in the BPMN context: Business Process spec first approach","title":"Philosophies around BPMN"},{"location":"#goals-and-development-guidelines-for-the-engine","text":"The lib-bpmn-engine library follows these architectural goals/guidelines being graceful in reading BPMN files support multiple (named) instances of the engine within the same process support BPMN elements, as guided/requested by the community (means incremental feature development) not being standard compliant (as in tolerating some errors) no linting/validation of BPMN no database support (just (de-)marshalling is planned) no locking/synchronization support (should be implemented by the application itself) no built-in user interface (but export of events, so UI could be use or built) no built-in scheduler/timer (but can be provided) no support for BPMN compensation spec (which I consider bad practice, for the same reason, why roll-back is more complicated than roll-forward-with-fix)","title":"goals and development guidelines (for the engine)"},{"location":"#main-features","text":"in-memory BPMN engine, to be embedded in other Go applications able to execute BPMN 2.0 xml workflow models no database support by design - there's just marshalling/unmarshalling support planned generic event export interface to make internal processing transparent basic BPMN element supported, see Supported Elements support dynamic decision via expression language support The following experimental features have known limitations, and rather showcase some capabilities. Experimental features might even be removed in the future! EXPERIMENTAL: event exporter for Zeebe Simple Process Monitor","title":"Main Features"},{"location":"advanced-microservice/","text":"A microservice, showcasing a fictionary shopping use case The following example snippet shows how a microservice could use BPMN engine to process orders and provides status feedback to clients. For this example, we leverage messages and timers, to orchestrate some tasks. For this microservice, we first define some simple API. package main import \"net/http\" func initHttpRoutes () { http . HandleFunc ( \"/api/order\" , handleOrder ) // POST new or GET existing Order http . HandleFunc ( \"/api/receive-payment\" , handleReceivePayment ) // webhook for the payment system http . HandleFunc ( \"/show-process.html\" , handleShowProcess ) // shows the BPMN diagram http . HandleFunc ( \"/index.html\" , handleIndex ) // the index page http . HandleFunc ( \"/\" , handleIndex ) // the index page http . HandleFunc ( \"/ordering-items-workflow.bpmn\" , handleOrderingItemsWorkflowBpmn ) // the BPMN file, for documentation purpose } Then we initialize the BPMN engine and register a trivial handler, which just prints on STDOUT. package main import ( \"fmt\" \"time\" \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\" ) func initBpmnEngine () { bpmnEngine = bpmn_engine . New ( \"Ordering-Microservice\" ) process , _ = bpmnEngine . LoadFromBytes ( OrderingItemsWorkflowBpmn ) bpmnEngine . NewTaskHandler (). Id ( \"validate-order\" ). Handler ( printHandler ) bpmnEngine . NewTaskHandler (). Id ( \"send-bill\" ). Handler ( printHandler ) bpmnEngine . NewTaskHandler (). Id ( \"send-friendly-reminder\" ). Handler ( printHandler ) bpmnEngine . NewTaskHandler (). Id ( \"update-accounting\" ). Handler ( updateAccountingHandler ) bpmnEngine . NewTaskHandler (). Id ( \"package-and-deliver\" ). Handler ( printHandler ) bpmnEngine . NewTaskHandler (). Id ( \"send-cancellation\" ). Handler ( printHandler ) } func printHandler ( job bpmn_engine . ActivatedJob ) { // do important stuff here println ( fmt . Sprintf ( \"%s >>> Executing job '%s'\" , time . Now (), job . GetElementId ())) job . Complete () } func updateAccountingHandler ( job bpmn_engine . ActivatedJob ) { println ( fmt . Sprintf ( \"%s >>> Executing job '%s'\" , time . Now (), job . GetElementId ())) println ( fmt . Sprintf ( \"%s >>> update ledger revenue account with amount=%s\" , time . Now (), job . GetVariable ( \"amount\" ))) job . Complete () } Since the /api/order endpoint can be requested with the GET or POST method, we need to make the handler smart enough to either create an order process instance or respond a status package main import ( _ \"embed\" \"fmt\" \"net/http\" \"strconv\" ) func handleOrder ( writer http . ResponseWriter , request * http . Request ) { if request . Method == \"POST\" { createNewOrder ( writer , request ) } else if request . Method == \"GET\" { showOrderStatus ( writer , request ) } } func createNewOrder ( writer http . ResponseWriter , request * http . Request ) { instance , _ := bpmnEngine . CreateAndRunInstance ( process . ProcessKey , nil ) redirectUrl := fmt . Sprintf ( \"/show-process.html?orderId=%d\" , instance . GetInstanceKey ()) http . Redirect ( writer , request , redirectUrl , http . StatusFound ) } func showOrderStatus ( writer http . ResponseWriter , request * http . Request ) { orderIdStr := request . URL . Query ()[ \"orderId\" ][ 0 ] orderId , _ := strconv . ParseInt ( orderIdStr , 10 , 64 ) instance := bpmnEngine . FindProcessInstanceById ( orderId ) if instance != nil { // we re-use this GET request to ensure we catch up the timers - ideally the service uses internal timers instead bpmnEngine . RunOrContinueInstance ( instance . GetInstanceKey ()) bytes , _ := prepareJsonResponse ( orderIdStr , instance . GetState (), instance . GetCreatedAt ()) writer . Header (). Set ( \"Content-Type\" , \"application/json\" ) writer . Write ( bytes ) return } http . NotFound ( writer , request ) } Also, for the incoming payments, our microservice provides an endpoint so that we get informed by external payment service. This handler sends a message to the process instance and continues. package main import ( _ \"embed\" \"net/http\" \"strconv\" ) func handleReceivePayment ( writer http . ResponseWriter , request * http . Request ) { orderIdStr := request . FormValue ( \"orderId\" ) amount := request . FormValue ( \"amount\" ) if len ( orderIdStr ) > 0 && len ( amount ) > 0 { orderId , _ := strconv . ParseInt ( orderIdStr , 10 , 64 ) processInstance := bpmnEngine . FindProcessInstanceById ( orderId ) if processInstance != nil { vars := map [ string ] interface {}{ \"amount\" : amount , } bpmnEngine . PublishEventForInstance ( processInstance . GetInstanceKey (), \"payment-received\" , vars ) bpmnEngine . RunOrContinueInstance ( processInstance . GetInstanceKey ()) http . Redirect ( writer , request , \"/\" , http . StatusFound ) return } } writer . WriteHeader ( 400 ) writer . Write ([] byte ( \"Bad request: the request must contain form data with 'orderId' and 'amount', and the order must exist\" )) } To get the snippet compile, see the other sources in the examples/ordering_microservice/ folder.","title":"Microservice & REST API"},{"location":"advanced-microservice/#a-microservice-showcasing-a-fictionary-shopping-use-case","text":"The following example snippet shows how a microservice could use BPMN engine to process orders and provides status feedback to clients. For this example, we leverage messages and timers, to orchestrate some tasks. For this microservice, we first define some simple API. package main import \"net/http\" func initHttpRoutes () { http . HandleFunc ( \"/api/order\" , handleOrder ) // POST new or GET existing Order http . HandleFunc ( \"/api/receive-payment\" , handleReceivePayment ) // webhook for the payment system http . HandleFunc ( \"/show-process.html\" , handleShowProcess ) // shows the BPMN diagram http . HandleFunc ( \"/index.html\" , handleIndex ) // the index page http . HandleFunc ( \"/\" , handleIndex ) // the index page http . HandleFunc ( \"/ordering-items-workflow.bpmn\" , handleOrderingItemsWorkflowBpmn ) // the BPMN file, for documentation purpose } Then we initialize the BPMN engine and register a trivial handler, which just prints on STDOUT. package main import ( \"fmt\" \"time\" \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\" ) func initBpmnEngine () { bpmnEngine = bpmn_engine . New ( \"Ordering-Microservice\" ) process , _ = bpmnEngine . LoadFromBytes ( OrderingItemsWorkflowBpmn ) bpmnEngine . NewTaskHandler (). Id ( \"validate-order\" ). Handler ( printHandler ) bpmnEngine . NewTaskHandler (). Id ( \"send-bill\" ). Handler ( printHandler ) bpmnEngine . NewTaskHandler (). Id ( \"send-friendly-reminder\" ). Handler ( printHandler ) bpmnEngine . NewTaskHandler (). Id ( \"update-accounting\" ). Handler ( updateAccountingHandler ) bpmnEngine . NewTaskHandler (). Id ( \"package-and-deliver\" ). Handler ( printHandler ) bpmnEngine . NewTaskHandler (). Id ( \"send-cancellation\" ). Handler ( printHandler ) } func printHandler ( job bpmn_engine . ActivatedJob ) { // do important stuff here println ( fmt . Sprintf ( \"%s >>> Executing job '%s'\" , time . Now (), job . GetElementId ())) job . Complete () } func updateAccountingHandler ( job bpmn_engine . ActivatedJob ) { println ( fmt . Sprintf ( \"%s >>> Executing job '%s'\" , time . Now (), job . GetElementId ())) println ( fmt . Sprintf ( \"%s >>> update ledger revenue account with amount=%s\" , time . Now (), job . GetVariable ( \"amount\" ))) job . Complete () } Since the /api/order endpoint can be requested with the GET or POST method, we need to make the handler smart enough to either create an order process instance or respond a status package main import ( _ \"embed\" \"fmt\" \"net/http\" \"strconv\" ) func handleOrder ( writer http . ResponseWriter , request * http . Request ) { if request . Method == \"POST\" { createNewOrder ( writer , request ) } else if request . Method == \"GET\" { showOrderStatus ( writer , request ) } } func createNewOrder ( writer http . ResponseWriter , request * http . Request ) { instance , _ := bpmnEngine . CreateAndRunInstance ( process . ProcessKey , nil ) redirectUrl := fmt . Sprintf ( \"/show-process.html?orderId=%d\" , instance . GetInstanceKey ()) http . Redirect ( writer , request , redirectUrl , http . StatusFound ) } func showOrderStatus ( writer http . ResponseWriter , request * http . Request ) { orderIdStr := request . URL . Query ()[ \"orderId\" ][ 0 ] orderId , _ := strconv . ParseInt ( orderIdStr , 10 , 64 ) instance := bpmnEngine . FindProcessInstanceById ( orderId ) if instance != nil { // we re-use this GET request to ensure we catch up the timers - ideally the service uses internal timers instead bpmnEngine . RunOrContinueInstance ( instance . GetInstanceKey ()) bytes , _ := prepareJsonResponse ( orderIdStr , instance . GetState (), instance . GetCreatedAt ()) writer . Header (). Set ( \"Content-Type\" , \"application/json\" ) writer . Write ( bytes ) return } http . NotFound ( writer , request ) } Also, for the incoming payments, our microservice provides an endpoint so that we get informed by external payment service. This handler sends a message to the process instance and continues. package main import ( _ \"embed\" \"net/http\" \"strconv\" ) func handleReceivePayment ( writer http . ResponseWriter , request * http . Request ) { orderIdStr := request . FormValue ( \"orderId\" ) amount := request . FormValue ( \"amount\" ) if len ( orderIdStr ) > 0 && len ( amount ) > 0 { orderId , _ := strconv . ParseInt ( orderIdStr , 10 , 64 ) processInstance := bpmnEngine . FindProcessInstanceById ( orderId ) if processInstance != nil { vars := map [ string ] interface {}{ \"amount\" : amount , } bpmnEngine . PublishEventForInstance ( processInstance . GetInstanceKey (), \"payment-received\" , vars ) bpmnEngine . RunOrContinueInstance ( processInstance . GetInstanceKey ()) http . Redirect ( writer , request , \"/\" , http . StatusFound ) return } } writer . WriteHeader ( 400 ) writer . Write ([] byte ( \"Bad request: the request must contain form data with 'orderId' and 'amount', and the order must exist\" )) } To get the snippet compile, see the other sources in the examples/ordering_microservice/ folder.","title":"A microservice, showcasing a fictionary shopping use case"},{"location":"advanced-timers/","text":"Timers The lib-bpmn-engine supports timer intermediate catch events , which are very useful to model typical timeout scenarios. The one above \"ask $1 million question\" demonstrates a 10 seconds timeout to give the correct answer or lose the whole \"game\". This is a best-practice example, for how to model (business) timeouts or deadlines. How to model timer/scheduler? In BPMN processes, Timer Intermediate Catch events can be used in combination with Event Based Gateway, to exclusively select one execution path in the process. When a timer event happens before a message event, then the example $1 million question game is lost. Architectural choices for timer/scheduler The Problem: implementing a timer/scheduler very much depends on your context or non-functional requirements. E.g. you might run lib-bpmn-engine as part of a single batch job instance OR you have a web service implement which is running with 3 instances. Both scenarios do require different implementation approaches, how to deal with long-running processes. Choices: Depending on your scenario/use case, you might implement a trivial blocking loop, like in the example code below. In multi-instance environments, you might better use a central scheduler, to avoid each instance of the application (using lib-bpmn-engine) is doing its own un-coordinated timing/scheduling. lib-bpmn-engine design lib-bpmn-engine is not aware of how it's deployed lib-bpmn-engine will not block, when timers are set == this is like an implicit pause lib-bpmn-engine delegates scheduler/timer responsibility to the developer (==you) In a nutshell: The lib-bpmn-engine does create such timer event objects and will pause the process execution. This means, an external ticker/scheduler is required, to continue the process instance. Trivial example, blocking local execution The code snippet below demonstrates a trivial example, how to execute processes with timers. Here, the execution is blocking until the due time is reached. This might fit in a scenario, where you have a single instance running in a batch-job like environment. Depending on your context, you might choose some external ticker/scheduler, to check for active scheduled timer events. package main import ( \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\" \"github.com/nitram509/lib-bpmn-engine/pkg/spec/BPMN20/process_instance\" \"time\" ) func main () { bpmnEngine := bpmn_engine . New ( \"a name\" ) process , err := bpmnEngine . LoadFromFile ( \"timeout-example.bpmn\" ) if err != nil { panic ( \"file \\\"timeout-example.bpmn\\\" can't be read.\" ) } // just some dummy handler to complete the tasks/jobs registerDummyTaskHandlers ( bpmnEngine ) instance , err := bpmnEngine . CreateAndRunInstance ( process . ProcessKey , nil ) println ( instance . GetState ()) // still ACTIVE at this point printScheduledTimerInformation ( bpmnEngine . GetTimersScheduled ()[ 0 ]) // sleep() for 2 seconds, before trying to continue the process instance // this for-loop essentially will block until the process instance has completed OR an error occurred for ; instance . GetState () == process_instance . ACTIVE && err == nil ; time . Sleep ( 2 * time . Second ) { println ( \"tick.\" ) // by re-running, the engine will check for active timers and might continue execution, // if timer.DueAt has passed _ , err = bpmnEngine . RunOrContinueInstance ( instance . GetInstanceKey ()) } println ( instance . GetState ()) // finally completed } To get the snippet compile, see the full sources in the examples/timers/ folder.","title":"Timers & Schedulers"},{"location":"advanced-timers/#timers","text":"The lib-bpmn-engine supports timer intermediate catch events , which are very useful to model typical timeout scenarios. The one above \"ask $1 million question\" demonstrates a 10 seconds timeout to give the correct answer or lose the whole \"game\". This is a best-practice example, for how to model (business) timeouts or deadlines.","title":"Timers"},{"location":"advanced-timers/#how-to-model-timerscheduler","text":"In BPMN processes, Timer Intermediate Catch events can be used in combination with Event Based Gateway, to exclusively select one execution path in the process. When a timer event happens before a message event, then the example $1 million question game is lost.","title":"How to model timer/scheduler?"},{"location":"advanced-timers/#architectural-choices-for-timerscheduler","text":"The Problem: implementing a timer/scheduler very much depends on your context or non-functional requirements. E.g. you might run lib-bpmn-engine as part of a single batch job instance OR you have a web service implement which is running with 3 instances. Both scenarios do require different implementation approaches, how to deal with long-running processes. Choices: Depending on your scenario/use case, you might implement a trivial blocking loop, like in the example code below. In multi-instance environments, you might better use a central scheduler, to avoid each instance of the application (using lib-bpmn-engine) is doing its own un-coordinated timing/scheduling.","title":"Architectural choices for timer/scheduler"},{"location":"advanced-timers/#lib-bpmn-engine-design","text":"lib-bpmn-engine is not aware of how it's deployed lib-bpmn-engine will not block, when timers are set == this is like an implicit pause lib-bpmn-engine delegates scheduler/timer responsibility to the developer (==you) In a nutshell: The lib-bpmn-engine does create such timer event objects and will pause the process execution. This means, an external ticker/scheduler is required, to continue the process instance.","title":"lib-bpmn-engine design"},{"location":"advanced-timers/#trivial-example-blocking-local-execution","text":"The code snippet below demonstrates a trivial example, how to execute processes with timers. Here, the execution is blocking until the due time is reached. This might fit in a scenario, where you have a single instance running in a batch-job like environment. Depending on your context, you might choose some external ticker/scheduler, to check for active scheduled timer events. package main import ( \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\" \"github.com/nitram509/lib-bpmn-engine/pkg/spec/BPMN20/process_instance\" \"time\" ) func main () { bpmnEngine := bpmn_engine . New ( \"a name\" ) process , err := bpmnEngine . LoadFromFile ( \"timeout-example.bpmn\" ) if err != nil { panic ( \"file \\\"timeout-example.bpmn\\\" can't be read.\" ) } // just some dummy handler to complete the tasks/jobs registerDummyTaskHandlers ( bpmnEngine ) instance , err := bpmnEngine . CreateAndRunInstance ( process . ProcessKey , nil ) println ( instance . GetState ()) // still ACTIVE at this point printScheduledTimerInformation ( bpmnEngine . GetTimersScheduled ()[ 0 ]) // sleep() for 2 seconds, before trying to continue the process instance // this for-loop essentially will block until the process instance has completed OR an error occurred for ; instance . GetState () == process_instance . ACTIVE && err == nil ; time . Sleep ( 2 * time . Second ) { println ( \"tick.\" ) // by re-running, the engine will check for active timers and might continue execution, // if timer.DueAt has passed _ , err = bpmnEngine . RunOrContinueInstance ( instance . GetInstanceKey ()) } println ( instance . GetState ()) // finally completed } To get the snippet compile, see the full sources in the examples/timers/ folder.","title":"Trivial example, blocking local execution"},{"location":"advanced-zeebe/","text":"Visualize process state via Zeebe Simple Monitor Overview Since lib-bpmn-engine runs embedded in your application, it's a challenge, to \"see what's happen inside\". Therefore, this library exports all internal events and you can register various event exporters. That might be a simple STDOUT exporter, or one that exports to a dedicated visualisation application. There's an Open Source Web UI for monitoring BPMN processes Zeebe Simple Monitor . Fortunately, the authors did design the monitor as an event consumer. Thus, by exporting Zeebe compatible events, you're able to monitor your processes. Screenshot Architecture As shown in the architecture diagram, your App and Zeebe Simple Montor don't connect to each other, but rather your app needs to connect to a Hazelcast Ringbuffer . Once connected, the built-in Zeebe Exporter will export events to this Ringbuffer. The Zeebe Simple Monitor (ZSM) is a Java based application, which connects to the Ringbuffer as well and fetches events from there. Once fetched, ZSM stores events in it's own database. The ZSM database can be configured to your preferences. Please, keep in mind, this architecture does not support any namespacing. Means, when multiple of your applications connect to the same Ringbuffer, all events will be mixed up. That's less an issue technically, but might confuse your users. Limitations As with the first and experimental release, just a handful of events are supported. This means, in contract to a full flavoured Zeebe cluster, events are missing and will not be shown. That said, basic functionality in Simple Monitor is given. Once you application restarts, workflows are newly deployed and so they are shown multiple times in Zeebe Simple Monitor (ZSM). This is because of the design/architecture of lib-bpmn-engine. With a new start of your app, a new ID will be assigned and ZSM ha no chance to detect former workflows/processes are identical. Housekeeping is missing in ZSM, which results in events just stack up and will slow down your database. The ringbuffer support in Hazelcast's Go client is not yet officially merged. So, lib-bpmn-engine uses a feature branch of the client to write to the ringbuffer. Setup for tinkering/experimenting Here are some hints, how you can quickly spin up a setup for experimenting. If you aim for a more production ready setup, please read&learn how to do such with Hazelcast and Zeebe Simple Monitor on their official web sites individually. Hazelcast First, you need a running Hazelcast. The simplest way is using Docker... docker run -p 5701 :5701 hazelcast/hazelcast:latest Zeebe Simple Monitor Using Docker, also allows you to start a Zeebe Simple Monitor... docker run -p 8082 :8082 -e \"zeebe.client.worker.hazelcast.connection= $( hostname ) :5701\" ghcr.io/camunda-community-hub/zeebe-simple-monitor:2.4.0 ``` \u26a0\ufe0f The above Docker containers do expose each service without any authentication! This mean, anyone in your network can connect to it - please, use a proper firewall or other tools to secure your system. Zeebe Exporter Showcase App package main import ( \"context\" \"fmt\" \"github.com/hazelcast/hazelcast-go-client\" \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\" \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine/exporter/zeebe\" ) func main () { // create a new named engine bpmnEngine := bpmn_engine . New ( \"a name\" ) // the exporter will require a running Hazelcast cluster at 127.0.0.1:5701 ctx := context . TODO () config := hazelcast . Config {} config . Cluster . Network . SetAddresses ( \"localhost:5701\" ) client , err := hazelcast . StartNewClientWithConfig ( ctx , config ) // create the client exporter , _ := zeebe . NewExporterWithHazelcastClient ( client ) // register the exporter bpmnEngine . AddEventExporter ( & exporter ) // basic example loading a BPMN from file, process , err := bpmnEngine . LoadFromFile ( \"simple_task.bpmn\" ) if err != nil { panic ( \"file \\\"simple_task.bpmn\\\" can't be read.\" ) } // register a handler for a service task by defined task type bpmnEngine . NewTaskHandler (). Id ( \"hello-world\" ). Handler ( printContextHandler ) // and execute the process instance , _ := bpmnEngine . CreateAndRunInstance ( process . ProcessKey , nil ) println ( fmt . Sprintf ( \"instanceKey=%d\" , instance . GetInstanceKey ())) } func printContextHandler ( job bpmn_engine . ActivatedJob ) { // trivial handler is requires job . Complete () }","title":"Zeebe Exporter (visualization)"},{"location":"advanced-zeebe/#visualize-process-state-via-zeebe-simple-monitor","text":"","title":"Visualize process state via Zeebe Simple Monitor"},{"location":"advanced-zeebe/#overview","text":"Since lib-bpmn-engine runs embedded in your application, it's a challenge, to \"see what's happen inside\". Therefore, this library exports all internal events and you can register various event exporters. That might be a simple STDOUT exporter, or one that exports to a dedicated visualisation application. There's an Open Source Web UI for monitoring BPMN processes Zeebe Simple Monitor . Fortunately, the authors did design the monitor as an event consumer. Thus, by exporting Zeebe compatible events, you're able to monitor your processes.","title":"Overview"},{"location":"advanced-zeebe/#screenshot","text":"","title":"Screenshot"},{"location":"advanced-zeebe/#architecture","text":"As shown in the architecture diagram, your App and Zeebe Simple Montor don't connect to each other, but rather your app needs to connect to a Hazelcast Ringbuffer . Once connected, the built-in Zeebe Exporter will export events to this Ringbuffer. The Zeebe Simple Monitor (ZSM) is a Java based application, which connects to the Ringbuffer as well and fetches events from there. Once fetched, ZSM stores events in it's own database. The ZSM database can be configured to your preferences. Please, keep in mind, this architecture does not support any namespacing. Means, when multiple of your applications connect to the same Ringbuffer, all events will be mixed up. That's less an issue technically, but might confuse your users.","title":"Architecture"},{"location":"advanced-zeebe/#limitations","text":"As with the first and experimental release, just a handful of events are supported. This means, in contract to a full flavoured Zeebe cluster, events are missing and will not be shown. That said, basic functionality in Simple Monitor is given. Once you application restarts, workflows are newly deployed and so they are shown multiple times in Zeebe Simple Monitor (ZSM). This is because of the design/architecture of lib-bpmn-engine. With a new start of your app, a new ID will be assigned and ZSM ha no chance to detect former workflows/processes are identical. Housekeeping is missing in ZSM, which results in events just stack up and will slow down your database. The ringbuffer support in Hazelcast's Go client is not yet officially merged. So, lib-bpmn-engine uses a feature branch of the client to write to the ringbuffer.","title":"Limitations"},{"location":"advanced-zeebe/#setup-for-tinkeringexperimenting","text":"Here are some hints, how you can quickly spin up a setup for experimenting. If you aim for a more production ready setup, please read&learn how to do such with Hazelcast and Zeebe Simple Monitor on their official web sites individually.","title":"Setup for tinkering/experimenting"},{"location":"advanced-zeebe/#hazelcast","text":"First, you need a running Hazelcast. The simplest way is using Docker... docker run -p 5701 :5701 hazelcast/hazelcast:latest","title":"Hazelcast"},{"location":"advanced-zeebe/#zeebe-simple-monitor","text":"Using Docker, also allows you to start a Zeebe Simple Monitor... docker run -p 8082 :8082 -e \"zeebe.client.worker.hazelcast.connection= $( hostname ) :5701\" ghcr.io/camunda-community-hub/zeebe-simple-monitor:2.4.0 ``` \u26a0\ufe0f The above Docker containers do expose each service without any authentication! This mean, anyone in your network can connect to it - please, use a proper firewall or other tools to secure your system.","title":"Zeebe Simple Monitor"},{"location":"advanced-zeebe/#zeebe-exporter-showcase-app","text":"package main import ( \"context\" \"fmt\" \"github.com/hazelcast/hazelcast-go-client\" \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\" \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine/exporter/zeebe\" ) func main () { // create a new named engine bpmnEngine := bpmn_engine . New ( \"a name\" ) // the exporter will require a running Hazelcast cluster at 127.0.0.1:5701 ctx := context . TODO () config := hazelcast . Config {} config . Cluster . Network . SetAddresses ( \"localhost:5701\" ) client , err := hazelcast . StartNewClientWithConfig ( ctx , config ) // create the client exporter , _ := zeebe . NewExporterWithHazelcastClient ( client ) // register the exporter bpmnEngine . AddEventExporter ( & exporter ) // basic example loading a BPMN from file, process , err := bpmnEngine . LoadFromFile ( \"simple_task.bpmn\" ) if err != nil { panic ( \"file \\\"simple_task.bpmn\\\" can't be read.\" ) } // register a handler for a service task by defined task type bpmnEngine . NewTaskHandler (). Id ( \"hello-world\" ). Handler ( printContextHandler ) // and execute the process instance , _ := bpmnEngine . CreateAndRunInstance ( process . ProcessKey , nil ) println ( fmt . Sprintf ( \"instanceKey=%d\" , instance . GetInstanceKey ())) } func printContextHandler ( job bpmn_engine . ActivatedJob ) { // trivial handler is requires job . Complete () }","title":"Zeebe Exporter Showcase App"},{"location":"expression-syntax/","text":"Expression Syntax Cite from the BPMN 2.0 specification... BPMN does not itself provide a built-in model for describing structure of data or an Expression language for querying that data. Instead, it formalizes hooks that allow for externally defined data structures and Expression languages. This lib-bpmn-engine uses antonmedv/expr library for evaluate expression. Noteworthy syntax differences Expression lib-bpmn-engine Camunda v8 (Zeebe) Comment Comparisons = foobar == true = foobar = true In Zeebe just use a single equals (=) sign, which causes trouble in lib-bpmn-engine Expression in exclusive gateways Expressions used in exclusive gateways must evaluate to a single boolean value. Examples for such expressions are listed below. Some other engines use the equal sign ( = ) for these boolean expression. The lib-bpmn-engine allows both, for compatibility reasons. This means, the result of price > 10 is equal to = price > 10 . Variables Variables can be provided to the engine, when a task is executed. The library is type aware. E.g. in the examples below (boolean expressions), owner must of type string and totalPrice of type int or float. Boolean expressions Operator Description Example = (just one equals sign) equal to owner = \"Paul\" != not equal to owner != \"Paul\" < less than totalPrice < 25 <= less than or equal to totalPrice <= 25 > greater than totalPrice > 25 >= greater than or equal to totalPrice >= 25 Mathematical expressions Basic mathematical operations are supported and can be used in conditional expressions. E.g. if you define these variables and provide them to the context of a process instance, then the expression sum >= foo + bar will evaluate to true . variables := map [ string ] interface {}{ \"foo\" : 3 , \"bar\" : 7 , \"sum\" : 10 , } bpmnEngine . CreateAndRunInstance ( key , variables ) 'Expr' Language Definition This is the full expr language specification, copied from this antonmedv's source Supported Literals The package supports: strings - single and double quotes (e.g. \"hello\" , 'hello' ) numbers - e.g. 103 , 2.5 , .5 arrays - e.g. [1, 2, 3] maps - e.g. {foo: \"bar\"} booleans - true and false nil - nil Digit separators Integer literals may contain digit separators to allow digit grouping into more legible forms. Example: 10_000_000_000 Accessing Public Properties Public properties on structs can be accessed by using the . syntax. If you pass an array into an expression, use the [] syntax to access array keys. foo . Array [ 0 ]. Value Functions and Methods Functions may be called using () syntax. The . syntax can also be used to call methods on an struct. price . String () Supported Operators The package comes with a lot of operators: Arithmetic Operators + (addition) - (subtraction) * (multiplication) / (division) % (modulus) ** (pow) Example: life + universe + everything Comparison Operators == (equal) != (not equal) < (less than) > (greater than) <= (less than or equal to) >= (greater than or equal to) Logical Operators not or ! and or && or or || Example: life < universe || life < everything String Operators + (concatenation) matches (regex match) contains (string contains) startsWith (has prefix) endsWith (has suffix) To test if a string does not match a regex, use the logical not operator in combination with the matches operator: not ( \"foo\" matches \"^b.+\" ) You must use parenthesis because the unary operator not has precedence over the binary operator matches . Example: 'Arthur' + ' ' + 'Dent' Result will be set to Arthur Dent . Membership Operators in (contain) not in (does not contain) Example: user . Group in [ \"human_resources\" , \"marketing\" ] \"foo\" in { foo : 1 , bar : 2 } Numeric Operators .. (range) Example: user . Age in 18..45 The range is inclusive: 1..3 == [ 1 , 2 , 3 ] Ternary Operators foo ? 'yes' : 'no' Example: user . Age > 30 ? \"mature\" : \"immature\" Builtin functions len (length of array, map or string) all (will return true if all element satisfies the predicate) none (will return true if all element does NOT satisfies the predicate) any (will return true if any element satisfies the predicate) one (will return true if exactly ONE element satisfies the predicate) filter (filter array by the predicate) map (map all items with the closure) count (returns number of elements what satisfies the predicate) Examples: Ensure all tweets are less than 280 chars. all ( Tweets , {. Size < 280 }) Ensure there is exactly one winner. one ( Participants , {. Winner }) Closures {...} (closure) Closures allowed only with builtin functions. To access current item use # symbol. map ( 0..9 , { # / 2 }) If the item of array is struct, it's possible to access fields of struct with omitted # symbol ( #.Value becomes .Value ). filter ( Tweets , { len (. Value ) > 280 }) Slices array[:] (slice) Slices can work with arrays or strings. Example: Variable array is [1,2,3,4,5] . array [ 1 : 5 ] == [ 2 , 3 , 4 ] array [ 3 : ] == [ 4 , 5 ] array [ : 4 ] == [ 1 , 2 , 3 ] array [ : ] == array","title":"Expression Syntax"},{"location":"expression-syntax/#expression-syntax","text":"Cite from the BPMN 2.0 specification... BPMN does not itself provide a built-in model for describing structure of data or an Expression language for querying that data. Instead, it formalizes hooks that allow for externally defined data structures and Expression languages. This lib-bpmn-engine uses antonmedv/expr library for evaluate expression.","title":"Expression Syntax"},{"location":"expression-syntax/#noteworthy-syntax-differences","text":"Expression lib-bpmn-engine Camunda v8 (Zeebe) Comment Comparisons = foobar == true = foobar = true In Zeebe just use a single equals (=) sign, which causes trouble in lib-bpmn-engine","title":"Noteworthy syntax differences"},{"location":"expression-syntax/#expression-in-exclusive-gateways","text":"Expressions used in exclusive gateways must evaluate to a single boolean value. Examples for such expressions are listed below. Some other engines use the equal sign ( = ) for these boolean expression. The lib-bpmn-engine allows both, for compatibility reasons. This means, the result of price > 10 is equal to = price > 10 .","title":"Expression in exclusive gateways"},{"location":"expression-syntax/#variables","text":"Variables can be provided to the engine, when a task is executed. The library is type aware. E.g. in the examples below (boolean expressions), owner must of type string and totalPrice of type int or float.","title":"Variables"},{"location":"expression-syntax/#boolean-expressions","text":"Operator Description Example = (just one equals sign) equal to owner = \"Paul\" != not equal to owner != \"Paul\" < less than totalPrice < 25 <= less than or equal to totalPrice <= 25 > greater than totalPrice > 25 >= greater than or equal to totalPrice >= 25","title":"Boolean expressions"},{"location":"expression-syntax/#mathematical-expressions","text":"Basic mathematical operations are supported and can be used in conditional expressions. E.g. if you define these variables and provide them to the context of a process instance, then the expression sum >= foo + bar will evaluate to true . variables := map [ string ] interface {}{ \"foo\" : 3 , \"bar\" : 7 , \"sum\" : 10 , } bpmnEngine . CreateAndRunInstance ( key , variables )","title":"Mathematical expressions"},{"location":"expression-syntax/#expr-language-definition","text":"This is the full expr language specification, copied from this antonmedv's source","title":"'Expr' Language Definition"},{"location":"expression-syntax/#supported-literals","text":"The package supports: strings - single and double quotes (e.g. \"hello\" , 'hello' ) numbers - e.g. 103 , 2.5 , .5 arrays - e.g. [1, 2, 3] maps - e.g. {foo: \"bar\"} booleans - true and false nil - nil","title":"Supported Literals"},{"location":"expression-syntax/#digit-separators","text":"Integer literals may contain digit separators to allow digit grouping into more legible forms. Example: 10_000_000_000","title":"Digit separators"},{"location":"expression-syntax/#accessing-public-properties","text":"Public properties on structs can be accessed by using the . syntax. If you pass an array into an expression, use the [] syntax to access array keys. foo . Array [ 0 ]. Value","title":"Accessing Public Properties"},{"location":"expression-syntax/#functions-and-methods","text":"Functions may be called using () syntax. The . syntax can also be used to call methods on an struct. price . String ()","title":"Functions and Methods"},{"location":"expression-syntax/#supported-operators","text":"The package comes with a lot of operators:","title":"Supported Operators"},{"location":"expression-syntax/#arithmetic-operators","text":"+ (addition) - (subtraction) * (multiplication) / (division) % (modulus) ** (pow) Example: life + universe + everything","title":"Arithmetic Operators"},{"location":"expression-syntax/#comparison-operators","text":"== (equal) != (not equal) < (less than) > (greater than) <= (less than or equal to) >= (greater than or equal to)","title":"Comparison Operators"},{"location":"expression-syntax/#logical-operators","text":"not or ! and or && or or || Example: life < universe || life < everything","title":"Logical Operators"},{"location":"expression-syntax/#string-operators","text":"+ (concatenation) matches (regex match) contains (string contains) startsWith (has prefix) endsWith (has suffix) To test if a string does not match a regex, use the logical not operator in combination with the matches operator: not ( \"foo\" matches \"^b.+\" ) You must use parenthesis because the unary operator not has precedence over the binary operator matches . Example: 'Arthur' + ' ' + 'Dent' Result will be set to Arthur Dent .","title":"String Operators"},{"location":"expression-syntax/#membership-operators","text":"in (contain) not in (does not contain) Example: user . Group in [ \"human_resources\" , \"marketing\" ] \"foo\" in { foo : 1 , bar : 2 }","title":"Membership Operators"},{"location":"expression-syntax/#numeric-operators","text":".. (range) Example: user . Age in 18..45 The range is inclusive: 1..3 == [ 1 , 2 , 3 ]","title":"Numeric Operators"},{"location":"expression-syntax/#ternary-operators","text":"foo ? 'yes' : 'no' Example: user . Age > 30 ? \"mature\" : \"immature\"","title":"Ternary Operators"},{"location":"expression-syntax/#builtin-functions","text":"len (length of array, map or string) all (will return true if all element satisfies the predicate) none (will return true if all element does NOT satisfies the predicate) any (will return true if any element satisfies the predicate) one (will return true if exactly ONE element satisfies the predicate) filter (filter array by the predicate) map (map all items with the closure) count (returns number of elements what satisfies the predicate) Examples: Ensure all tweets are less than 280 chars. all ( Tweets , {. Size < 280 }) Ensure there is exactly one winner. one ( Participants , {. Winner })","title":"Builtin functions"},{"location":"expression-syntax/#closures","text":"{...} (closure) Closures allowed only with builtin functions. To access current item use # symbol. map ( 0..9 , { # / 2 }) If the item of array is struct, it's possible to access fields of struct with omitted # symbol ( #.Value becomes .Value ). filter ( Tweets , { len (. Value ) > 280 })","title":"Closures"},{"location":"expression-syntax/#slices","text":"array[:] (slice) Slices can work with arrays or strings. Example: Variable array is [1,2,3,4,5] . array [ 1 : 5 ] == [ 2 , 3 , 4 ] array [ 3 : ] == [ 4 , 5 ] array [ : 4 ] == [ 1 , 2 , 3 ] array [ : ] == array","title":"Slices"},{"location":"getting-started/","text":"Getting Started Here are two example on how to use the library. Hello World Example Assuming this simple 'Hello World' BPMN example should just print \"hello world\". \\ Then a simple (and verbose) code to execute this looks like this package main import ( \"fmt\" \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\" ) func main () { // create a new named engine bpmnEngine := bpmn_engine . New ( \"a name\" ) // basic example loading a BPMN from file, process , err := bpmnEngine . LoadFromFile ( \"simple_task.bpmn\" ) if err != nil { panic ( \"file \\\"simple_task.bpmn\\\" can't be read.\" ) } // register a handler for a service task by defined task type bpmnEngine . NewTaskHandler (). Id ( \"hello-world\" ). Handler ( printContextHandler ) // setup some variables variables := map [ string ] interface {}{} variables [ \"foo\" ] = \"bar\" // and execute the process bpmnEngine . CreateAndRunInstance ( process . ProcessKey , variables ) } func printContextHandler ( job bpmn_engine . ActivatedJob ) { println ( \"< Hello World >\" ) println ( fmt . Sprintf ( \"ElementId = %s\" , job . GetElementId ())) println ( fmt . Sprintf ( \"BpmnProcessId = %s\" , job . GetBpmnProcessId ())) println ( fmt . Sprintf ( \"ProcessDefinitionKey = %d\" , job . GetProcessDefinitionKey ())) println ( fmt . Sprintf ( \"ProcessDefinitionVersion = %d\" , job . GetProcessDefinitionVersion ())) println ( fmt . Sprintf ( \"CreatedAt = %s\" , job . GetCreatedAt ())) println ( fmt . Sprintf ( \"Variable 'foo' = %s\" , job . GetVariable ( \"foo\" ))) job . Complete () // don't forget this one, or job.Fail(\"foobar\") }","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Here are two example on how to use the library.","title":"Getting Started"},{"location":"getting-started/#hello-world-example","text":"Assuming this simple 'Hello World' BPMN example should just print \"hello world\". \\ Then a simple (and verbose) code to execute this looks like this package main import ( \"fmt\" \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\" ) func main () { // create a new named engine bpmnEngine := bpmn_engine . New ( \"a name\" ) // basic example loading a BPMN from file, process , err := bpmnEngine . LoadFromFile ( \"simple_task.bpmn\" ) if err != nil { panic ( \"file \\\"simple_task.bpmn\\\" can't be read.\" ) } // register a handler for a service task by defined task type bpmnEngine . NewTaskHandler (). Id ( \"hello-world\" ). Handler ( printContextHandler ) // setup some variables variables := map [ string ] interface {}{} variables [ \"foo\" ] = \"bar\" // and execute the process bpmnEngine . CreateAndRunInstance ( process . ProcessKey , variables ) } func printContextHandler ( job bpmn_engine . ActivatedJob ) { println ( \"< Hello World >\" ) println ( fmt . Sprintf ( \"ElementId = %s\" , job . GetElementId ())) println ( fmt . Sprintf ( \"BpmnProcessId = %s\" , job . GetBpmnProcessId ())) println ( fmt . Sprintf ( \"ProcessDefinitionKey = %d\" , job . GetProcessDefinitionKey ())) println ( fmt . Sprintf ( \"ProcessDefinitionVersion = %d\" , job . GetProcessDefinitionVersion ())) println ( fmt . Sprintf ( \"CreatedAt = %s\" , job . GetCreatedAt ())) println ( fmt . Sprintf ( \"Variable 'foo' = %s\" , job . GetVariable ( \"foo\" ))) job . Complete () // don't forget this one, or job.Fail(\"foobar\") }","title":"Hello World Example"},{"location":"implementation-task-handlers/","text":"Task Handlers Declaration & Definition You can declare service tasks and users tasks in BPMN. Both declarations have in common, that you must specify a unique ID per task element. Per each ID, you can add/define a single task handler, when using the engine. For some use cases you might want to add/define a single task handler for multiple tasks. This is, where the task 'type' comes into play. This library is compatible with Zeebe's 'taskDefinition' extension, which allows you to declare a single 'type' for many tasks in the BPMN, and thus you're able to use just a single handle for this type. For user tasks you can define an 'assignee' or multiple 'candidate groups' as in Zeebe. In case multiple handlers are defined and would potentially match the declaration, the specific ones have precedence over the generic ones. Also, first defined one wins. For service tasks this means, the handler with ID matching is called instead of the handler with TYPE matching. And for user tasks this means, the handler with ID matching is called instead of the handler with assignee matching instead of the handler with a candidate group matching. \u2139\ufe0f In contrast to Zeebe, the declarations for 'type', 'assignee', and 'candidateGroups' are not evaluated but just treated as static string constants in lib-bpmn-engine. Service Tasks vs. User Tasks The engine (as of now) handles service tasks and user tasks almost equal. There are some differences you should consider, when implementing your handler(s). add/register handlers for 'id' os possible for all tasks add/register a handler for 'type' is only possible for service tasks add/register a handler for 'assignee' or 'candidate groups' is only possible for user tasks user tasks can be paused, but service tasks not a service task handler must always call .Complete() or .Fail() a user task handler might just return (or call .Complete() or call .Fail() ), and being resumed later in time (see below) Pause and resume User Tasks Processing a simple user task typically involves external action by a human. The lib-bpmn-engine will therefore pause a process instance, when such a task is reached. The example code mimics the external action via the externalEvent variable. Typically, you will create and run an instance, then notify a human and once the human responses with some event, you will continue the process. The .Complete() and .Fail() methods let you handle errors. package main import ( \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\" ) func main () { bpmnEngine := bpmn_engine . New ( \"name\" ) process , _ := bpmnEngine . LoadFromFile ( \"simple-user-task.bpmn\" ) bpmnEngine . NewTaskHandler (). Assignee ( \"assignee\" ). Handler ( userTaskHandler ()) instance , _ := bpmnEngine . CreateAndRunInstance ( process . ProcessKey , nil ) // ... just wait for the human completed his/her task bpmnEngine . RunOrContinueInstance ( instance . GetInstanceKey ()) } var externalEvent = \"none\" func userTaskHandler () func ( job bpmn_engine . ActivatedJob ) { return func ( job bpmn_engine . ActivatedJob ) { if externalEvent == \"none\" { // send notification to user } if externalEvent == \"user is done\" { job . Complete () } if externalEvent == \"user is done but wrong response\" { job . Fail ( \"error in user task\" ) } // just return and so 'pause' the process instance } }","title":"Task Handlers"},{"location":"implementation-task-handlers/#task-handlers","text":"","title":"Task Handlers"},{"location":"implementation-task-handlers/#declaration-definition","text":"You can declare service tasks and users tasks in BPMN. Both declarations have in common, that you must specify a unique ID per task element. Per each ID, you can add/define a single task handler, when using the engine. For some use cases you might want to add/define a single task handler for multiple tasks. This is, where the task 'type' comes into play. This library is compatible with Zeebe's 'taskDefinition' extension, which allows you to declare a single 'type' for many tasks in the BPMN, and thus you're able to use just a single handle for this type. For user tasks you can define an 'assignee' or multiple 'candidate groups' as in Zeebe. In case multiple handlers are defined and would potentially match the declaration, the specific ones have precedence over the generic ones. Also, first defined one wins. For service tasks this means, the handler with ID matching is called instead of the handler with TYPE matching. And for user tasks this means, the handler with ID matching is called instead of the handler with assignee matching instead of the handler with a candidate group matching. \u2139\ufe0f In contrast to Zeebe, the declarations for 'type', 'assignee', and 'candidateGroups' are not evaluated but just treated as static string constants in lib-bpmn-engine.","title":"Declaration &amp; Definition"},{"location":"implementation-task-handlers/#service-tasks-vs-user-tasks","text":"The engine (as of now) handles service tasks and user tasks almost equal. There are some differences you should consider, when implementing your handler(s). add/register handlers for 'id' os possible for all tasks add/register a handler for 'type' is only possible for service tasks add/register a handler for 'assignee' or 'candidate groups' is only possible for user tasks user tasks can be paused, but service tasks not a service task handler must always call .Complete() or .Fail() a user task handler might just return (or call .Complete() or call .Fail() ), and being resumed later in time (see below)","title":"Service Tasks vs. User Tasks"},{"location":"implementation-task-handlers/#pause-and-resume-user-tasks","text":"Processing a simple user task typically involves external action by a human. The lib-bpmn-engine will therefore pause a process instance, when such a task is reached. The example code mimics the external action via the externalEvent variable. Typically, you will create and run an instance, then notify a human and once the human responses with some event, you will continue the process. The .Complete() and .Fail() methods let you handle errors. package main import ( \"github.com/nitram509/lib-bpmn-engine/pkg/bpmn_engine\" ) func main () { bpmnEngine := bpmn_engine . New ( \"name\" ) process , _ := bpmnEngine . LoadFromFile ( \"simple-user-task.bpmn\" ) bpmnEngine . NewTaskHandler (). Assignee ( \"assignee\" ). Handler ( userTaskHandler ()) instance , _ := bpmnEngine . CreateAndRunInstance ( process . ProcessKey , nil ) // ... just wait for the human completed his/her task bpmnEngine . RunOrContinueInstance ( instance . GetInstanceKey ()) } var externalEvent = \"none\" func userTaskHandler () func ( job bpmn_engine . ActivatedJob ) { return func ( job bpmn_engine . ActivatedJob ) { if externalEvent == \"none\" { // send notification to user } if externalEvent == \"user is done\" { job . Complete () } if externalEvent == \"user is done but wrong response\" { job . Fail ( \"error in user task\" ) } // just return and so 'pause' the process instance } }","title":"Pause and resume User Tasks"},{"location":"roadmap/","text":"Roadmap This is an overview of the roadmap. The project is managed on Github's lib-bpmn-engine milestones page. \u2705 v0.1.0 progress milestone v0.1.0 For the first release I would like to have service tasks and events fully supported. \u2705 v0.2.0 progress milestone v0.2.0 With basic element support, I would like to add visualization/monitoring capabilities. If the idea of using Zeebe's exporter protocol is not too complex, that would be ideal. If not, a simple console logger might do the job as well. Also, I would like to add expression language support as well as support for correlation keys \u2699\ufe0f v0.3.0 progress milestone v0.3.0 One last but very important feature I aim for is the ability to load & store state. Which means, that you as app developer would be able to persistent in-flight process instances for later restoring and completion. \ud83d\udd2e\ufe0f v0.?.0 \ud83e\udd14more elements to be supported ... or more events to be exported","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"This is an overview of the roadmap. The project is managed on Github's lib-bpmn-engine milestones page.","title":"Roadmap"},{"location":"roadmap/#v010","text":"progress milestone v0.1.0 For the first release I would like to have service tasks and events fully supported.","title":"\u2705 v0.1.0"},{"location":"roadmap/#v020","text":"progress milestone v0.2.0 With basic element support, I would like to add visualization/monitoring capabilities. If the idea of using Zeebe's exporter protocol is not too complex, that would be ideal. If not, a simple console logger might do the job as well. Also, I would like to add expression language support as well as support for correlation keys","title":"\u2705 v0.2.0"},{"location":"roadmap/#v030","text":"progress milestone v0.3.0 One last but very important feature I aim for is the ability to load & store state. Which means, that you as app developer would be able to persistent in-flight process instances for later restoring and completion.","title":"\u2699\ufe0f v0.3.0"},{"location":"roadmap/#v00","text":"\ud83e\udd14more elements to be supported ... or more events to be exported","title":"\ud83d\udd2e\ufe0f v0.?.0"},{"location":"supported-elements/","text":"These BPMN elements are supported by the latest release of lib-bpmn-engine. There are some comments as well, which describe the level of support per each element. Start Event multiple start events are supported and are triggered in order of appearance. End Event multiple end events are supported as well. Service Task you can define task handlers for one or multiple tasks (by ID or by Type) get & set variables from/to context (of the instance) is possible variable mapping is supported (for input and output, see Variables ) User Task you can define task handlers for one or multiple tasks (by assignee or by candidate groups) equally handled like service tasks get & set variables from/to context (of the instance) is possible variable mapping is supported (for input and output, see Variables ) Gateways The Parallel Gateway and the Exclusive Gateway do allow fork and join logic, as well as parallel execution. The library does not support real parallel execution, but flows are processed in order of appearance in the BPMN file. Forks controlled and uncontrolled forks are supported parallel gateway supported exclusive gateway with conditions supported Joins uncontrolled and exclusive joins are supported parallel joins are supported Exclusive Gateway fully supported, incl. conditional expressions per each outgoing flow Parallel Gateway fully supported, incl. conditional expressions per each outgoing flow Event Based Gateway fully supported Message Intermediate Catch Event at the moment, just matching/correlation by name supported variable mapping is supported (for output, see Variables ) Timer Intermediate Catch Event supported a ticker/scheduler needs to be externally provided, see Timers Variables Input Variables Input mappings can be used to create new variables. They can be defined on service tasks and user task. When an input mapping is applied, it creates a new local variable in the scope (visible in the task handler) where the mapping is defined. Output Variables Output mappings can be used to customize how job/message variables are merged into the process instance. They can be defined on service tasks, user tasks, and message catch events. Within a task handler, variables are set as local variables (local scope). When the handler completes the job, the output mappings are applied to the variables and create new variables in this scope. The new variables are merged into the parent scope (typically the process instance). If there is no mapping for a job/message variable, the variable is not merged. In other words: if one or more variables are defined, only these are mapped. If no output mappings are defined, all job/message variables are merged into the process instance.","title":"Supported Elements"},{"location":"supported-elements/#start-event","text":"multiple start events are supported and are triggered in order of appearance.","title":"Start Event"},{"location":"supported-elements/#end-event","text":"multiple end events are supported as well.","title":"End Event"},{"location":"supported-elements/#service-task","text":"you can define task handlers for one or multiple tasks (by ID or by Type) get & set variables from/to context (of the instance) is possible variable mapping is supported (for input and output, see Variables )","title":"Service Task"},{"location":"supported-elements/#user-task","text":"you can define task handlers for one or multiple tasks (by assignee or by candidate groups) equally handled like service tasks get & set variables from/to context (of the instance) is possible variable mapping is supported (for input and output, see Variables )","title":"User Task"},{"location":"supported-elements/#gateways","text":"The Parallel Gateway and the Exclusive Gateway do allow fork and join logic, as well as parallel execution. The library does not support real parallel execution, but flows are processed in order of appearance in the BPMN file. Forks controlled and uncontrolled forks are supported parallel gateway supported exclusive gateway with conditions supported Joins uncontrolled and exclusive joins are supported parallel joins are supported","title":"Gateways"},{"location":"supported-elements/#exclusive-gateway","text":"fully supported, incl. conditional expressions per each outgoing flow","title":"Exclusive Gateway"},{"location":"supported-elements/#parallel-gateway","text":"fully supported, incl. conditional expressions per each outgoing flow","title":"Parallel Gateway"},{"location":"supported-elements/#event-based-gateway","text":"fully supported","title":"Event Based Gateway"},{"location":"supported-elements/#message-intermediate-catch-event","text":"at the moment, just matching/correlation by name supported variable mapping is supported (for output, see Variables )","title":"Message Intermediate Catch Event"},{"location":"supported-elements/#timer-intermediate-catch-event","text":"supported a ticker/scheduler needs to be externally provided, see Timers","title":"Timer Intermediate Catch Event"},{"location":"supported-elements/#variables","text":"","title":"Variables"},{"location":"supported-elements/#input-variables","text":"Input mappings can be used to create new variables. They can be defined on service tasks and user task. When an input mapping is applied, it creates a new local variable in the scope (visible in the task handler) where the mapping is defined.","title":"Input Variables"},{"location":"supported-elements/#output-variables","text":"Output mappings can be used to customize how job/message variables are merged into the process instance. They can be defined on service tasks, user tasks, and message catch events. Within a task handler, variables are set as local variables (local scope). When the handler completes the job, the output mappings are applied to the variables and create new variables in this scope. The new variables are merged into the parent scope (typically the process instance). If there is no mapping for a job/message variable, the variable is not merged. In other words: if one or more variables are defined, only these are mapped. If no output mappings are defined, all job/message variables are merged into the process instance.","title":"Output Variables"}]}